USE GRAPH social
CREATE QUERY dijkstra (VERTEX source, BOOL display) FOR GRAPH social {
/* The Bellman-Ford algorithm for single-Source Shortest Path 
   on directed/undirected graph with positive weight.
   It will not detect negative cycle in this algorithm. 
*/
        TYPEDEF TUPLE<FLOAT dist, VERTEX pred> pathTuple;    
        HeapAccum<pathTuple>(1, dist ASC) @minPath;
	HeapAccum<pathTuple>(1, dist ASC) @@minNode;
        ListAccum<VERTEX> @path;                 # shortest path FROM source
        SetAccum<EDGE> @@edgeSet;               # list of all edges, if display is needed
        OrAccum @visited;
	OrAccum @choosed;
        STRING sourceName;
        INT iter;
        BOOL negativeCycle;
        total = {source};                       # the connected vertices
        start = {source};
	nodes = {source};

              
        ##### Get the connected vertices
        start = SELECT s
                FROM start:s
                ACCUM s.@minPath += pathTuple(0, s),
                      s.@visited = TRUE,
                      s.@path += s,
		      s.@choosed = TRUE;
        WHILE start.size() > 0 DO
                start = SELECT t
                        FROM start:s -((Friend):e)-> :t
                        WHERE NOT t.@visited
                        ACCUM t.@visited = TRUE;
                total = total UNION start;
        END;
        nodes = total;
  ##### Do V-1 iterations: Consider whether each edge lowers the best-known distance.
	
	WHILE total.size()>0 DO
                tmp = SELECT s
                      FROM nodes:s -((Friend):e)-> :t
		      WHERE NOT t.@choosed
                      ACCUM 
			    IF s.@choosed THEN
                            t.@minPath += pathTuple(s.@minPath.top().dist + e.weight, s)
			    END
		      POST-ACCUM
                            IF t.@minPath.size()>0 AND t.@minPath.top().dist < GSQL_INT_MAX THEN
                            @@minNode += t.@minPath.top()
                            END;

		total = SELECT s
			FROM total:s
			ACCUM
			   IF abs(s.@minPath.top().dist - @@minNode.top().dist)<0.0001 THEN
				s.@choosed = TRUE
			   END
			HAVING NOT s.@choosed;
		@@minNode.clear(); 
        END;
        
  ##### Calculate the paths #####
        start = {source};
        tmp = SELECT s
              FROM nodes:s
              WHERE s != source
              ACCUM s.@visited = FALSE;
	#PRINT nodes;
	WHILE start.size() > 0 DO # Limit the number of hops
                start = SELECT t
                        FROM start:s -((Friend):e)-> :t
                        WHERE NOT t.@visited
                        ACCUM IF s == t.@minPath.top().pred THEN 
                                  t.@visited = TRUE,
                                  t.@path += s.@path,
                                  t.@path += t
                              END;
	#	PRINT start;
        END;
          
  ##### Print the results #####
        PRINT nodes[nodes.@minPath, nodes.@path];
        IF display THEN
                tmp = SELECT s
                      FROM nodes:s -((Friend):e)-> :t
                      ACCUM @@edgeSet += e;
                PRINT @@edgeSet;
        END;
}
